  - [X] 显示已加入房间人员信息
  - [X] 加入房间，是通过房间name？
  - [X] 游戏大厅
  - [ ] 根据每个玩家点击开始的状态设置ready样式
  - [ ] 每个玩家都ready，开始
  - [X] 房主的button是开始，其他是ready
  - [X] 退出登陆
  - [ ] 退出房间功能
  - [ ] 开始后，次序问题、可视化方位编排
  - [X] 前、后数据结构统一（interface等）
  - [X] 开始后不能加入
  - [ ] 开始后退出，结束游戏，房间不解散
  - [ ] 游戏逻辑新开一个网关处理
  - [ ] 使用 useCallback 优化 Menu 等父组件的 handle 函数，避免子组件不必要更新？有可能是某些 log 重复输出的原因

### 开局与局中摸牌，以及游戏状态初步

  - [X] 以下摸发牌阶段是在确认出牌顺序前，程序修改一下。
  - [X] 摸牌堆，一张黑一张白不示数，在画面中心，与CardPile 公用一个 svg，摸牌时点一次拿一张。
  - [X] 摸牌堆每点一次，生成一个牌对象，移动到左下角 tmp 区，销毁，同时 CardPile 对象淡入生成牌对象（或者都用同一个对象?不行）
  - [X] nestJs 和 socket.io 后台是不是多线程？不管了，统一实时获取
  - [X] 搞清楚为什么 CardPile 中连续 get 多次然后 insert，每张牌都可以正常插入，是 bug 还是正常代码逻辑
  - [X]] 开局时每人摸4张，每点一次摸牌时，都向服务器请求当前牌属性，造成的并发可能导致服务端计算出错。
          因此在摸完4张后，4个牌对象移动到 tmp 区背面朝上，与实际牌对象不采用同一个。每个 client 摸完后向服务端发送颜色数量，
          服务端发牌，这样每个 client 仅要请求一次。
  - [X] 第一轮所有人摸牌后，服务端验证可以开始，然后执行已有逻辑，房主发出请求，服务端广播出牌轮次
  - [X] 服务器存储牌堆: 用全局变量，存储 roomName -> cardPile 的映射，cardPile 对象分为黑白两个数组存储，（1个也行）
          具有 value、color、isShown(是否翻牌)、playerId(可过滤得出一个人的手牌,为null表示未发牌) 属性。
  - [X] 牌摸完后，摸牌堆不再显示相关颜色的牌
  - [X] clean code for BigCards
  - [X] 现在在拿取一张牌时，向后端请求剩余卡牌数量，若牌堆没牌，则不显示相应颜色 div。但在 turns 轮到自己时，也要获取一次。
  - [X] 摸牌阶段才显示牌堆，否则隐藏
  - [ ] 采用状态机标志所有游戏阶段，在组件中用 state 记录当前状态，用 useEffect 监听状态改变，做出下一步响应。跟后端的交互也
					可以整理到这里。
	- [ ] 摸牌堆做好点击次数逻辑限制，可以基于状态机判断.

### 所有玩家手牌的展示
	- [ ] 参考骰子布局，用 4 个 div 划分 GamePanel，作为每个玩家的手牌区域。区域根据 turns，高亮显示当前轮次的玩家
	- [ ] 简单起见，每个玩家的手牌均采用 div 实现，均具有暂存区，显示摸牌状态。数据用组件 state 存，新插入的牌高亮显示 1秒。
				（为什么用 div：svg 的添加事件，事件函数无法获取最新数据。例如事件函数打印 props 数据，每次调用事件打印的都会是添加事件那一时刻的props。因此若使用 svg，需要维护 svg 对象数组，每次拿到数据要重新覆盖事件，实现麻烦。而 props 改变导致重新渲染 div，所以 div 的事件一直是最新的。使用 svg 的目的是可以写插牌动画，比较美观，但实现过于复杂，不如使用 div 高亮显示新牌更直接。）
	- [ ] 注意除自己外的玩家手牌排序规则要相反。是从左到右降序。
  - [ ] 摸牌后开始猜牌逻辑，点击对方卡牌 div，选择数字，获得序号、数字、颜色属性，确认发送。

  - [ ] BigHint 组件的淡入淡出，计时组件
  - [ ] 进入房间界面的完善
  - [ ] 万能牌的拖动和插入